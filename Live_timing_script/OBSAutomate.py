import obsws_python as obs
import time
import random
import re

class transition():
    glissement = "Glissement"
    fondu = "Fondu"

class Scene():
    def __init__(self, name:str, minTime:int=None, maxTime:int=None, autoSwitch=True, Transition = transition.fondu) -> None:
        self.name = name
        self.minTime = minTime
        self.maxTime = maxTime
        self.allowedAutoSwitch = autoSwitch
        self.Transition = Transition
    
    def getDelay(self):
        return random.randint(self.minTime,self.maxTime)

class OBS_Auto():
    ManualSceneList = {
        "V_Grille"        :Scene("V_Grille", 30,75, autoSwitch=False), 
        "Serie"           :Scene("Serie_T_", 30,75, autoSwitch=False), 
        "V_Vue_Plafond_A_30_45"           :Scene("V_Vue_Plafond_A_30_45", 30,75, autoSwitch=False), 
        "Resultats"         :Scene("Resultats_T_", 30,75, autoSwitch=False), 
        "Comptage"         :Scene("V_Vue_Comptage_A_30_45", 30,75, autoSwitch=False)
    }
    autoSceneList = None

    AutoScenePattern =pattern = re.compile(r'_A_(\d+)_(\d+)')


    def __init__(self, IP, PassWord, Port=4455, debug=False, verbose=False) -> None:
        self.wsHhost = IP
        self.wsPort = Port
        self.wsPW = PassWord
        self.debug = debug
        self.verbose = verbose
        if not debug:
            self.OBS = obs.ReqClient(host=self.wsHhost, port=self.wsPort, password=self.wsPW, timeout=3)
        self.initialize()

    def initialize(self):
        self.previousTime = time.time()
        self.sceneDelay = 0
        self.init = True
        self.preventPodium = False
        self.toScene = None
        self.autoSwitchEnabled = True
        self.preventPodium = True
        self.AutoSwitchDelay = 0
        self.fromScene = None
        self.temporaryBlock = False
        self.CurrentTempBlockingScene = None
        self.blockingTime = 0
        self.previousBlockingTime = 0
        self.isBlocked = False

    def setScene(self, scene:Scene):
        try:
            self.OBS.set_current_scene_transition(self.toScene.Transition)
            self.OBS.set_current_program_scene(self.toScene.name)
        except:
            print("Failed switching scene")
    
    def updateAutoSceneList(self, InitialSceneList):
        # Extract all scene for which name matches "Name_A_xx_yy" and put them in auto switch list
        self.autoSceneList = []

        for scene in InitialSceneList:
            try:
                match = self.AutoScenePattern.search(scene['sceneName'])
                if match:
                    min_time, max_time = match.groups()
                    s = Scene(scene['sceneName'], int(min_time), int(max_time), autoSwitch=True)
                    self.autoSceneList.append(s)
            except KeyError:
                print("Issue with Scene list format, ensure it is generated by OBS.get_scene_list().scenes")
            except ValueError:
                print("Error while parsing scene durations, not adding scene to list.")
            
    def SetBlockingScene(self, Scene:Scene, Duration=10, Force=False):
        if (Force or not self.isBlocked) and not ("_B_" in self.OBS.get_current_program_scene().scene_name):
            self.previousBlockingTime = time.time()
            self.toScene = Scene
            self.fromScene = self.toScene
            self.isBlocked = True
            self.blockingTime = Duration
            if not self.debug:
                self.setScene(self.toScene)
            if self.verbose:
                print(f"Forcing {Scene.name}. Locking autoswitch for {Duration}s.")
        return self.isBlocked

    def updateBlockingState(self):
        # print(f"{'Blocked' if self.isBlocked else 'free'} - {time.time() - self.previousBlockingTime:0.2f} > {self.blockingTime}?")
        if (time.time() - self.previousBlockingTime > self.blockingTime) and self.isBlocked:
            self.isBlocked = False
            # self.AutoSwitchDelay = 2
            # time.time() - self.previousTime
            if self.verbose:
                print("Releasing autoswitch")

    def updateScene(self, ForceScene=None, ForceDuration=30):
        self.updateBlockingState()
        if (time.time() - self.previousTime > self.AutoSwitchDelay and self.autoSwitchEnabled) or (ForceScene is not None and not self.temporaryBlock):
            
            if "_B_" in self.OBS.get_current_program_scene().scene_name or self.isBlocked:
                if self.verbose:
                    print("Currently in blocking scene, no auto switch. AutoCheck again in 5s.")
                self.AutoSwitchDelay = 5
                return False

            self.previousTime = time.time()
            
            if ForceScene is not None:
                self.toScene = ForceScene
                self.AutoSwitchDelay=ForceDuration
            else:
                self.updateAutoSceneList(self.OBS.get_scene_list().scenes)
                self.toScene = self.autoSceneList[random.randint(1*self.preventPodium,len(self.autoSceneList)-1)]
                while (not self.toScene.allowedAutoSwitch) and self.fromScene == self.toScene:
                    self.toScene = self.autoSceneList[random.randint(1*self.preventPodium,len(self.autoSceneList)-1)]
                self.AutoSwitchDelay = self.toScene.getDelay()
            self.fromScene = self.toScene

            if not self.debug:
                self.setScene(self.toScene)

            if self.verbose:
                print(f"Switching from {self.fromScene.name} to {self.toScene.name}. Next switch in {self.AutoSwitchDelay}s.")
            return True